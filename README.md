# Head First 设计模式

#### 介绍
《Head First 设计模式》这本书自己写的 demo 和笔记



#### 目的

1. 代码重用性
2. 可读性
3. 可扩展性
4. 可用性
5. 使程序呈现高内聚，低耦合的特性



####  设计原则

* 多用组合，少用继承
* 针对接口编程，而不是针对实现编程
* 封装变化
* 为了交互对象之间的松耦合设计而努力
* 类应该对扩展开放，对修改关闭
* 要依赖抽象，不要依赖具体类



#### 模式

* 策略模式——定义算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户
* 观察者模式——在对象之间定义一对多的依赖，这样一来，当一个对象改变状态。依赖它的对象都会收到通知，并自动更新(Java Swing)
* 装饰者模式——动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案(Java IO)
* 工厂方法模式——定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类
* 抽象工厂模式——提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
* 单例模式——确保一个类只有一个实例，并提供一个全局访问点



#### 避免违反依赖倒置的原则

* 变量不可以持有具体类的引用
* 不要让类派生自具体类
* 不要覆盖基类中已经实现的方法



#### 关于枚举单例

1. 首先，在枚举中我们明确了构造方法限制为私有，在我们访问枚举实例时会执行构造方法。
2. 同时每个枚举实例都是static final类型的，也就表明只能被实例化一次。在调用构造方法时，我们的单例被实例化.
3. 也就是说，因为enum中的实例被保证只会被实例化一次，所以我们的INSTANCE也被保证实例化一次。 

* Enum这个类的声明 `public abstract class Enum<E extends Enum<E>> implements Comparable<E>, Serializable`。枚举提供了序列化机制，具体使用在网络连接，数据库连接，线程池等等。


> 单元素的枚举类型已经成为实现Singleton的最佳方法。		——《Effective Java》

